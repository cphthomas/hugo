// ;; A specification for serializing a ProseMirror document as
// Markdown/CommonMark text.
var MarkdownSerializer = function MarkdownSerializer(nodes, marks) {
  // :: Object<(MarkdownSerializerState, Node)> The node serializer
  // functions for this serializer.
  this.nodes = nodes
  // :: Object The mark serializer info.
  this.marks = marks
};

// :: (Node, ?Object) → string
// Serialize the content of the given node to
// [CommonMark](http://commonmark.org/).
MarkdownSerializer.prototype.serialize = function serialize (content, options) {
  var state = new MarkdownSerializerState(this.nodes, this.marks, options)
  state.renderContent(content)
  return state.out
};
exports.MarkdownSerializer = MarkdownSerializer

// :: MarkdownSerializer
// A serializer for the [basic schema](#schema).
var defaultMarkdownSerializer = new MarkdownSerializer({
  blockquote: function blockquote(state, node) {
    state.wrapBlock("> ", null, node, function () { return state.renderContent(node); })
  },
  code_block: function code_block(state, node) {
    if (!node.attrs.params) {
      state.wrapBlock("    ", null, node, function () { return state.text(node.textContent, false); })
    } else {
      state.write("```" + node.attrs.params + "\n")
      state.text(node.textContent, false)
      state.ensureNewLine()
      state.write("```")
      state.closeBlock(node)
    }
  },
  heading: function heading(state, node) {
    state.write(state.repeat("#", node.attrs.level) + " ")
    state.renderInline(node)
    state.closeBlock(node)
  },
  horizontal_rule: function horizontal_rule(state, node) {
    state.write(node.attrs.markup || "---")
    state.closeBlock(node)
  },
  bullet_list: function bullet_list(state, node) {
    state.renderList(node, "  ", function () { return (node.attrs.bullet || "*") + " "; })
  },
  ordered_list: function ordered_list(state, node) {
    var start = node.attrs.order || 1
    var maxW = String(start + node.childCount - 1).length
    var space = state.repeat(" ", maxW + 2)
    state.renderList(node, space, function (i) {
      var nStr = String(start + i)
      return state.repeat(" ", maxW - nStr.length) + nStr + ". "
    })
  },
  list_item: function list_item(state, node) {
    state.renderContent(node)
  },
  paragraph: function paragraph(state, node) {
    state.renderInline(node)
    state.closeBlock(node)
  },

  image: function image(state, node) {
    state.write("![" + state.esc(node.attrs.alt || "") + "](" + state.esc(node.attrs.src) +
                (node.attrs.title ? " " + state.quote(node.attrs.title) : "") + ")")
  },
  hard_break: function hard_break(state, node, parent, index) {
    for (var i = index + 1; i < parent.childCount; i++)
      { if (parent.child(i).type != node.type) {
        state.write("\\\n")
        return
      } }
  },
  text: function text(state, node) {
    state.text(node.text)
  }
}, {
  em: {open: "*", close: "*", mixable: true},
  strong: {open: "**", close: "**", mixable: true},
  link: {
    open: "[",
    close: function close(state, mark) {
      return "](" + state.esc(mark.attrs.href) + (mark.attrs.title ? " " + state.quote(mark.attrs.title) : "") + ")"
    }
  },
  code: {open: "`", close: "`"}
})
exports.defaultMarkdownSerializer = defaultMarkdownSerializer

// ;; This is an object used to track state and expose
// methods related to markdown serialization. Instances are passed to
// node and mark serialization methods (see `toMarkdown`).
var MarkdownSerializerState = function MarkdownSerializerState(nodes, marks, options) {
  this.nodes = nodes
  this.marks = marks
  this.delim = this.out = ""
  this.closed = false
  this.inTightList = false
  // :: Object
  // The options passed to the serializer.
  this.options = options || {}
};

MarkdownSerializerState.prototype.flushClose = function flushClose (size) {
    var this$1 = this;

  if (this.closed) {
    if (!this.atBlank()) { this.out += "\n" }
    if (size == null) { size = 2 }
    if (size > 1) {
      var delimMin = this.delim
      var trim = /\s+$/.exec(delimMin)
      if (trim) { delimMin = delimMin.slice(0, delimMin.length - trim[0].length) }
      for (var i = 1; i < size; i++)
        { this$1.out += delimMin + "\n" }
    }
    this.closed = false
  }
};

// :: (string, ?string, Node, ())
// Render a block, prefixing each line with `delim`, and the first
// line in `firstDelim`. `node` should be the node that is closed at
// the end of the block, and `f` is a function that renders the
// content of the block.
MarkdownSerializerState.prototype.wrapBlock = function wrapBlock (delim, firstDelim, node, f) {
  var old = this.delim
  this.write(firstDelim || delim)
  this.delim += delim
  f()
  this.delim = old
  this.closeBlock(node)
};

MarkdownSerializerState.prototype.atBlank = function atBlank () {
  return /(^|\n)$/.test(this.out)
};

// :: ()
// Ensure the current content ends with a newline.
MarkdownSerializerState.prototype.ensureNewLine = function ensureNewLine () {
  if (!this.atBlank()) { this.out += "\n" }
};

// :: (?string)
// Prepare the state for writing output (closing closed paragraphs,
// adding delimiters, and so on), and then optionally add content
// (unescaped) to the output.
MarkdownSerializerState.prototype.write = function write (content) {
  this.flushClose()
  if (this.delim && this.atBlank())
    { this.out += this.delim }
  if (content) { this.out += content }
};

// :: (Node)
// Close the block for the given node.
MarkdownSerializerState.prototype.closeBlock = function closeBlock (node) {
  this.closed = node
};

// :: (string, ?bool)
// Add the given text to the document. When escape is not `false`,
// it will be escaped.
MarkdownSerializerState.prototype.text = function text (text$1, escape) {
    var this$1 = this;

  var lines = text$1.split("\n")
  for (var i = 0; i < lines.length; i++) {
    var startOfLine = this$1.atBlank() || this$1.closed
    this$1.write()
    this$1.out += escape !== false ? this$1.esc(lines[i], startOfLine) : lines[i]
    if (i != lines.length - 1) { this$1.out += "\n" }
  }
};

// :: (Node)
// Render the given node as a block.
MarkdownSerializerState.prototype.render = function render (node, parent, index) {
  if (typeof parent == "number") { throw new Error("!") }
  this.nodes[node.type.name](this, node, parent, index)
};

// :: (Node)
// Render the contents of `parent` as block nodes.
MarkdownSerializerState.prototype.renderContent = function renderContent (parent) {
    var this$1 = this;

  parent.forEach(function (node, _, i) { return this$1.render(node, parent, i); })
};

// :: (Node)
// Render the contents of `parent` as inline content.
MarkdownSerializerState.prototype.renderInline = function renderInline (parent) {
    var this$1 = this;

  var active = []
  var progress = function (node, _, index) {
    var marks = node ? node.marks : []
    var code = marks.length && marks[marks.length - 1].type.isCode && marks[marks.length - 1]
    var len = marks.length - (code ? 1 : 0)

    // Try to reorder 'mixable' marks, such as em and strong, which
    // in Markdown may be opened and closed in different order, so
    // that order of the marks for the token matches the order in
    // active.
    outer: for (var i = 0; i < len; i++) {
      var mark = marks[i]
      if (!this$1.marks[mark.type.name].mixable) { break }
      for (var j = 0; j < active.length; j++) {
        var other = active[j]
        if (!this$1.marks[other.type.name].mixable) { break }
        if (mark.eq(other)) {
          if (i > j)
            { marks = marks.slice(0, j).concat(mark).concat(marks.slice(j, i)).concat(marks.slice(i + 1, len)) }
          else if (j > i)
            { marks = marks.slice(0, i).concat(marks.slice(i + 1, j)).concat(mark).concat(marks.slice(j, len)) }
          continue outer
        }
      }
    }

    // Find the prefix of the mark set that didn't change
    var keep = 0
    while (keep < Math.min(active.length, len) && marks[keep].eq(active[keep])) { ++keep }

    // Close the marks that need to be closed
    while (keep < active.length)
      { this$1.text(this$1.markString(active.pop(), false), false) }

    // Open the marks that need to be opened
    while (active.length < len) {
      var add = marks[active.length]
      active.push(add)
      this$1.text(this$1.markString(add, true), false)
    }

    // Render the node. Special case code marks, since their content
    // may not be escaped.
    if (node) {
      if (code && node.isText)
        { this$1.text(this$1.markString(code, false) + node.text + this$1.markString(code, true), false) }
      else
        { this$1.render(node, parent, index) }
    }
  }
  parent.forEach(progress)
  progress(null)
};

// :: (Node, string, (number) → string)
// Render a node's content as a list. `delim` should be the extra
// indentation added to all lines except the first in an item,
// `firstDelim` is a function going from an item index to a
// delimiter for the first line of the item.
MarkdownSerializerState.prototype.renderList = function renderList (node, delim, firstDelim) {
    var this$1 = this;

  if (this.closed && this.closed.type == node.type)
    { this.flushClose(3) }
  else if (this.inTightList)
    { this.flushClose(1) }

  var prevTight = this.inTightList
  this.inTightList = node.attrs.tight
  node.forEach(function (child, _, i) {
    if (i && node.attrs.tight) { this$1.flushClose(1) }
    this$1.wrapBlock(delim, firstDelim(i), node, function () { return this$1.render(child, node, i); })
  })
  this.inTightList = prevTight
};

// :: (string, ?bool) → string
// Escape the given string so that it can safely appear in Markdown
// content. If `startOfLine` is true, also escape characters that
// has special meaning only at the start of the line.
MarkdownSerializerState.prototype.esc = function esc (str, startOfLine) {
  str = str.replace(/[`*\\~+\[\]]/g, "\\$&")
  if (startOfLine) { str = str.replace(/^[:#-*]/, "\\$&").replace(/^(\d+)\./, "$1\\.") }
  return str
};

MarkdownSerializerState.prototype.quote = function quote (str) {
  var wrap = str.indexOf('"') == -1 ? '""' : str.indexOf("'") == -1 ? "''" : "()"
  return wrap[0] + str + wrap[1]
};

// :: (string, number) → string
// Repeat the given string `n` times.
MarkdownSerializerState.prototype.repeat = function repeat (str, n) {
  var out = ""
  for (var i = 0; i < n; i++) { out += str }
  return out
};

// : (Mark, bool) → string
// Get the markdown string for a given opening or closing mark.
MarkdownSerializerState.prototype.markString = function markString (mark, open) {
  var info = this.marks[mark.type.name]
  var value = open ? info.open : info.close
  return typeof value == "string" ? value : value(this, mark)
};
exports.MarkdownSerializerState = MarkdownSerializerState
