var ref = require("prosemirror-state");
var Plugin = ref.Plugin;

// ::- Input rules are regular expressions describing a piece of text
// that, when typed, causes something to happen. This might be
// changing two dashes into an emdash, wrapping a paragraph starting
// with `"> "` into a blockquote, or something entirely different.
var InputRule = function InputRule(match, handler) {
  this.match = match
  this.handler = typeof handler == "string" ? stringHandler(handler) : handler
};
exports.InputRule = InputRule

function stringHandler(string) {
  return function(state, match, start, end) {
    var insert = string
    if (match[1]) {
      var offset = match[0].lastIndexOf(match[1])
      insert += match[0].slice(offset + match[1].length)
      start += offset
      var cutOff = start - end
      if (cutOff > 0) {
        insert = match[0].slice(offset - cutOff, offset) + insert
        start = end
      }
    }
    var marks = state.doc.marksAt(start)
    return state.tr.replaceWith(start, end, state.schema.text(insert, marks))
  }
}

var MAX_MATCH = 100

// :: (config: {rules: [InputRule]}) â†’ Plugin
// Create an input rules plugin. When enabled, it will cause text
// input that matches any of the given rules to trigger the rule's
// action, and binds the backspace key, when applied directly after an
// input rule triggered, to undo the rule's effect.
function inputRules(ref) {
  var rules = ref.rules;

  return new Plugin({
    state: {
      init: function init() { return null },
      applyAction: function applyAction(action, prev) {
        if (action.type == "transform") { return action.fromInputRule }
        if (action.type == "selection") { return null }
        return prev
      }
    },

    props: {
      handleTextInput: function handleTextInput(view, from, to, text) {
        var state = view.state, $from = state.doc.resolve(from)
        var textBefore = $from.parent.textBetween(Math.max(0, $from.parentOffset - MAX_MATCH), $from.parentOffset,
                                                  null, "\ufffc") + text
        for (var i = 0; i < rules.length; i++) {
          var match = rules[i].match.exec(textBefore)
          var transform = match && rules[i].handler(state, match, from - (match[0].length - text.length), to)
          if (!transform) { continue }
          view.props.onAction(transform.action({fromInputRule: {transform: transform, from: from, to: to, text: text}}))
          return true
        }
        return false
      },

      handleKeyDown: function handleKeyDown(view, event) {
        if (event.keyCode == 8) { return maybeUndoInputRule(view.state, view.props.onAction, this.getState(view.state)) }
        return false
      }
    }
  })
}
exports.inputRules = inputRules

function maybeUndoInputRule(state, onAction, undoable) {
  if (!undoable) { return false }
  var tr = state.tr, toUndo = undoable.transform
  for (var i = toUndo.steps.length - 1; i >= 0; i--)
    { tr.step(toUndo.steps[i].invert(toUndo.docs[i])) }
  var marks = tr.doc.marksAt(undoable.from)
  tr.replaceWith(undoable.from, undoable.to, state.schema.text(undoable.text, marks))
  onAction(tr.action())
  return true
}
