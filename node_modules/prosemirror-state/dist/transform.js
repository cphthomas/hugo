var ref = require("prosemirror-transform");
var Transform = ref.Transform;
var ref$1 = require("./selection");
var Selection = ref$1.Selection;

// ::- A selection-aware extension of `Transform`. Use
// [`EditorState.tr`](#state.EditorState.tr) to create an instance.
var EditorTransform = (function (Transform) {
  function EditorTransform(state) {
    Transform.call(this, state.doc)
    this.state = state
    this.curSelection = state.selection
    this.curSelectionAt = 0
    this.selectionSet = false
  }

  if ( Transform ) EditorTransform.__proto__ = Transform;
  EditorTransform.prototype = Object.create( Transform && Transform.prototype );
  EditorTransform.prototype.constructor = EditorTransform;

  var prototypeAccessors = { selection: {} };

  // :: Selection
  // The transform's current selection. This defaults to the
  // editor selection [mapped](#state.Selection.map) through the steps in
  // this transform, but can be overwritten with
  // [`setSelection`](#state.EditorTransform.setSelection).
  prototypeAccessors.selection.get = function () {
    if (this.curSelectionAt < this.steps.length) {
      this.curSelection = this.curSelection.map(this.doc, this.mapping.slice(this.curSelectionAt))
      this.curSelectionAt = this.steps.length
    }
    return this.curSelection
  };

  // :: (Selection) → EditorTransform
  // Update the transform's current selection. This will determine the
  // selection that the editor gets when the transform is applied.
  EditorTransform.prototype.setSelection = function setSelection (selection) {
    this.curSelection = selection
    this.curSelectionAt = this.steps.length
    this.selectionSet = true
    return this
  };

  // :: (Slice) → EditorTransform
  EditorTransform.prototype.replaceSelection = function replaceSelection (slice) {
    var ref = this.selection;
    var from = ref.from;
    var to = ref.to;
    var startLen = this.steps.length
    this.replaceRange(from, to, slice)
    // Move the selection to the position after the inserted content.
    // When that ended in an inline node, search backwards, to get the
    // position after that node. If not, search forward.
    var lastNode = slice.content.lastChild, lastParent = null
    for (var i = 0; i < slice.openRight; i++) {
      lastParent = lastNode
      lastNode = lastNode.lastChild
    }
    selectionToInsertionEnd(this, startLen, (lastNode ? lastNode.isInline : lastParent && lastParent.isTextblock) ? -1 : 1)
    return this
  };

  // :: (Node, ?bool) → EditorTransform
  // Replace the selection with the given node or slice, or delete it
  // if `content` is null. When `inheritMarks` is true and the content
  // is inline, it inherits the marks from the place where it is
  // inserted.
  EditorTransform.prototype.replaceSelectionWith = function replaceSelectionWith (node, inheritMarks) {
    var ref = this.selection;
    var from = ref.from;
    var to = ref.to;
    var startLen = this.steps.length
    if (inheritMarks !== false)
      { node = node.mark(this.state.storedMarks || this.doc.marksAt(from, to > from)) }
    this.replaceRangeWith(from, to, node)
    selectionToInsertionEnd(this, startLen, node.isInline ? -1 : 1)
    return this
  };

  // :: () → EditorTransform
  // Delete the selection.
  EditorTransform.prototype.deleteSelection = function deleteSelection () {
    var ref = this.selection;
    var from = ref.from;
    var to = ref.to;
    return this.deleteRange(from, to)
  };

  // :: (string, from: ?number, to: ?number) → EditorTransform
  // Replace the given range, or the selection if no range is given,
  // with a text node containing the given string.
  EditorTransform.prototype.insertText = function insertText (text, from, to) {
    if ( to === void 0 ) to = from;

    if (from == null) {
      if (!text) { return this.deleteSelection() }
      return this.replaceSelectionWith(this.state.schema.text(text), true)
    } else {
      if (!text) { return this.deleteRange(from, to) }
      var node = this.state.schema.text(text, this.state.storedMarks || this.doc.marksAt(from, to > from))
      return this.replaceRangeWith(from, to, node)
    }
  };

  // :: (?Object) → TransformAction
  // Create a transform action. `options` can be given to add extra
  // properties to the action object.
  EditorTransform.prototype.action = function action (options) {
    var action = {type: "transform",
                  transform: this,
                  selection: this.selectionSet ? this.selection : null,
                  time: Date.now()}
    if (options) { for (var prop in options) { action[prop] = options[prop] } }
    return action
  };

  // :: () → TransformAction
  // Create a transform action with the `scrollIntoView` property set
  // to true (this is common enough to warrant a shortcut method).
  EditorTransform.prototype.scrollAction = function scrollAction () {
    return this.action({scrollIntoView: true})
  };

  Object.defineProperties( EditorTransform.prototype, prototypeAccessors );

  return EditorTransform;
}(Transform));
exports.EditorTransform = EditorTransform

function selectionToInsertionEnd(tr, startLen, bias) {
  if (tr.steps.length == startLen) { return }
  var map = tr.mapping.maps[tr.mapping.maps.length - 1], end
  map.forEach(function (_from, _to, _newFrom, newTo) { return end = newTo; })
  if (end != null) { tr.setSelection(Selection.near(tr.doc.resolve(end), bias)) }
}

// :: (Action, (transform: Transform)) → Action
// If, when dispatching actions, you need to extend a transform action
// with additional steps, you can use this helper. It takes an action
// and a function that extends a transform, and will update the action
// to reflect any additional steps. It won't call the function if the
// action is not a transform action or a
// [sealed](#state.TransformAction.sealed) transform action.
function extendTransformAction(action, f) {
  if (action.type != "transform" || action.sealed) { return action }
  var tr = action.transform, steps = tr.steps.length, set = tr.selectionSet
  f(tr)
  if (!set && tr.selectionSet)
    { action.selection = tr.selection }
  else if (action.selection && tr.steps.length > steps)
    { action.selection = action.selection.map(tr.doc, tr.mapping.slice(steps)) }
  return action
}
exports.extendTransformAction = extendTransformAction
