var RopeSequence = require("rope-sequence")
var ref = require("prosemirror-transform");
var Mapping = ref.Mapping;
var ref$1 = require("prosemirror-state");
var Selection = ref$1.Selection;
var Plugin = ref$1.Plugin;
var PluginKey = ref$1.PluginKey;

// ProseMirror's history isn't simply a way to roll back to a previous
// state, because ProseMirror supports applying changes without adding
// them to the history (for example during collaboration).
//
// To this end, each 'Branch' (one for the undo history and one for
// the redo history) keeps an array of 'Items', which can optionally
// hold a step (an actual undoable change), and always hold a position
// map (which is needed to move changes below them to apply to the
// current document).
//
// An item that has both a step and a selection JSON representation is
// the start of an 'event' — a group of changes that will be undone
// or redone at once. (It stores only the JSON, since that way we don't
// have to provide a document until the selection is actually applied,
// which is useful when compressing.)

// Used to schedule history compression
var max_empty_items = 500

var Branch = function Branch(items, eventCount) {
  this.items = items
  this.eventCount = eventCount
};

// : (Node, bool, ?Item) → ?{transform: Transform, selection: Object}
// Pop the latest event off the branch's history and apply it
// to a document transform.
Branch.prototype.popEvent = function popEvent (state, preserveItems) {
    var this$1 = this;

  if (this.eventCount == 0) { return null }

  var end = this.items.length
  for (;; end--) {
    var next = this$1.items.get(end - 1)
    if (next.selection) { --end; break }
  }

  var remap, mapFrom
  if (preserveItems) {
    remap = this.remapping(end, this.items.length)
    mapFrom = remap.maps.length
  }
  var transform = state.tr
  var selection, remaining
  var addAfter = [], addBefore = []

  this.items.forEach(function (item, i) {
    if (!item.step) {
      if (!remap) {
        remap = this$1.remapping(end, i + 1)
        mapFrom = remap.maps.length
      }
      mapFrom--
      addBefore.push(item)
      return
    }

    if (remap) {
      addBefore.push(new Item(item.map))
      var step = item.step.map(remap.slice(mapFrom)), map

      if (step && transform.maybeStep(step).doc) {
        map = transform.mapping.maps[transform.mapping.maps.length - 1]
        addAfter.push(new Item(map, null, null, addAfter.length + addBefore.length))
      }
      mapFrom--
      if (map) { remap.appendMap(map, mapFrom) }
    } else {
      transform.maybeStep(item.step)
    }

    if (item.selection) {
      selection = remap ? Selection.mapJSON(item.selection, remap.slice(mapFrom)) : item.selection
      remaining = new Branch(this$1.items.slice(0, end).append(addBefore.reverse().concat(addAfter)), this$1.eventCount - 1)
      return false
    }
  }, this.items.length, 0)

  return {remaining: remaining, transform: transform, selection: selection}
};

// : (Transform, Selection, Object)
// Create a new branch with the given transform added.
Branch.prototype.addTransform = function addTransform (transform, selection, histOptions) {
  var newItems = [], eventCount = this.eventCount + (selection ? 1 : 0)
  var oldItems = this.items, lastItem = !histOptions.preserveItems && oldItems.length ? oldItems.get(oldItems.length - 1) : null

  for (var i = 0; i < transform.steps.length; i++) {
    var step = transform.steps[i].invert(transform.docs[i])
    var item = new Item(transform.mapping.maps[i], step, selection), merged = (void 0)
    if (merged = lastItem && lastItem.merge(item)) {
      item = merged
      if (i) { newItems.pop() }
      else { oldItems = oldItems.slice(0, oldItems.length - 1) }
    }
    newItems.push(item)
    selection = null
    if (!histOptions.preserveItems) { lastItem = item }
  }
  var overflow = this.eventCount - histOptions.depth
  if (overflow > DEPTH_OVERFLOW) { oldItems = cutOffEvents(oldItems, overflow) }
  return new Branch(oldItems.append(newItems), eventCount)
};

Branch.prototype.remapping = function remapping (from, to) {
  var maps = [], mirrors = []
  this.items.forEach(function (item, i) {
    if (item.mirrorOffset != null) {
      var mirrorPos = i - item.mirrorOffset
      if (mirrorPos >= from) { mirrors.push(maps.length - item.mirrorOffset, maps.length) }
    }
    maps.push(item.map)
  }, from, to)
  return new Mapping(maps, mirrors)
};

Branch.prototype.addMaps = function addMaps (array) {
  if (this.eventCount == 0) { return this }
  return new Branch(this.items.append(array.map(function (map) { return new Item(map); })), this.eventCount)
};

// : ([StepMap], Transform, [number])
// When the collab module receives remote changes, the history has
// to know about those, so that it can adjust the steps that were
// rebased on top of the remote changes, and include the position
// maps for the remote changes in its array of items.
Branch.prototype.rebased = function rebased (rebasedTransform, rebasedCount) {
  if (!this.eventCount) { return this }

  var rebasedItems = [], start = this.items.length - rebasedCount, startPos = 0
  if (start < 0) {
    startPos = -start
    start = 0
  }

  var mapping = rebasedTransform.mapping
  var newUntil = rebasedTransform.steps.length

  var iRebased = startPos
  this.items.forEach(function (item) {
    var pos = mapping.getMirror(iRebased++)
    if (pos == null) { return }
    newUntil = Math.min(newUntil, pos)
    var map = mapping.maps[pos]
    if (item.step) {
      var step = rebasedTransform.steps[pos].invert(rebasedTransform.docs[pos])
      var selection = item.selection && Selection.mapJSON(item.selection, mapping.slice(iRebased - 1, pos))
      rebasedItems.push(new Item(map, step, selection))
    } else {
      rebasedItems.push(new Item(map))
    }
  }, start)

  var newMaps = []
  for (var i = rebasedCount; i < newUntil; i++)
    { newMaps.push(new Item(mapping.maps[i])) }
  var items = this.items.slice(0, start).append(newMaps).append(rebasedItems)
  var branch = new Branch(items, this.eventCount) // FIXME might update event count
  if (branch.emptyItemCount() > max_empty_items)
    { branch = branch.compress(this.items.length - rebasedItems.length) }
  return branch
};

Branch.prototype.emptyItemCount = function emptyItemCount () {
  var count = 0
  this.items.forEach(function (item) { if (!item.step) { count++ } })
  return count
};

// Compressing a branch means rewriting it to push the air (map-only
// items) out. During collaboration, these naturally accumulate
// because each remote change adds one. The `upto` argument is used
// to ensure that only the items below a given level are compressed,
// because `rebased` relies on a clean, untouched set of items in
// order to associate old items with rebased steps.
Branch.prototype.compress = function compress (upto) {
    if ( upto === void 0 ) upto = this.items.length;

  var remap = this.remapping(0, upto), mapFrom = remap.maps.length
  var items = [], events = 0
  this.items.forEach(function (item, i) {
    if (i >= upto) {
      items.push(item)
    } else if (item.step) {
      var step = item.step.map(remap.slice(mapFrom)), map = step && step.getMap()
      mapFrom--
      if (map) { remap.appendMap(map, mapFrom) }
      if (step) {
        var selection = item.selection && Selection.mapJSON(item.selection, remap.slice(mapFrom))
        if (selection) { events++ }
        var newItem = new Item(map.invert(), step, selection), merged, last = items.length - 1
        if (merged = items.length && items[last].merge(newItem))
          { items[last] = merged }
        else
          { items.push(newItem) }
      }
    } else if (item.map) {
      mapFrom--
    }
  }, this.items.length, 0)
  return new Branch(RopeSequence.from(items.reverse()), events)
};

Branch.empty = new Branch(RopeSequence.empty, 0)

function cutOffEvents(items, n) {
  var cutPoint
  items.forEach(function (item, i) {
    if (item.selection && (--n == 0)) {
      cutPoint = i
      return false
    }
  })
  return items.slice(cutPoint)
}

var Item = function Item(map, step, selection, mirrorOffset) {
  this.map = map
  this.step = step
  this.selection = selection
  this.mirrorOffset = mirrorOffset
};

Item.prototype.merge = function merge (other) {
  if (this.step && other.step && !other.selection) {
    var step = other.step.merge(this.step)
    if (step) { return new Item(step.getMap().invert(), step, this.selection) }
  }
};

// The value of the state field that tracks undo/redo history for that
// state. Will be stored in the plugin state when the history plugin
// is active.
var HistoryState = function HistoryState(done, undone, prevMap, prevTime) {
  this.done = done
  this.undone = undone
  this.prevMap = prevMap
  this.prevTime = prevTime
};
exports.HistoryState = HistoryState

var DEPTH_OVERFLOW = 20

// : (EditorState, Transform, Selection, Object)
// Record a transformation in undo history.
function recordTransform(history, selection, action, options) {
  var transform = action.transform
  if (action.historyState) {
    return action.historyState
  } else if (transform.steps.length == 0) {
    return history
  } else if (action.addToHistory !== false) {
    // Group transforms that occur in quick succession into one event.
    var newGroup = history.prevTime < (action.time || 0) - options.newGroupDelay ||
        !isAdjacentToLastStep(transform, history.prevMap, history.done)
    return new HistoryState(history.done.addTransform(transform, newGroup ? selection.toJSON() : null, options),
                            Branch.empty, transform.mapping.maps[transform.steps.length - 1], action.time)
  } else if (action.rebased) {
    // Used by the collab module to tell the history that some of its
    // content has been rebased.
    return new HistoryState(history.done.rebased(transform, action.rebased),
                            history.undone.rebased(transform, action.rebased),
                            history.prevMap && transform.mapping.maps[transform.steps.length - 1], history.prevTime)
  } else {
    return new HistoryState(history.done.addMaps(transform.mapping.maps),
                            history.undone.addMaps(transform.mapping.maps),
                            history.prevMap, history.prevTime)
  }
}

function isAdjacentToLastStep(transform, prevMap, done) {
  if (!prevMap) { return false }
  var firstMap = transform.mapping.maps[0], adjacent = false
  if (!firstMap) { return true }
  firstMap.forEach(function (start, end) {
    done.items.forEach(function (item) {
      if (item.step) {
        prevMap.forEach(function (_start, _end, rStart, rEnd) {
          if (start <= rEnd && end >= rStart) { adjacent = true }
        })
        return false
      } else {
        start = item.map.invert().map(start, -1)
        end = item.map.invert().map(end, 1)
      }
    }, done.items.length, 0)
  })
  return adjacent
}

// : (EditorState, bool, Object) → Object
// Apply the latest event from one branch to the document and optionally
// shift the event onto the other branch. Returns true when an event could
// be shifted.
function histAction(history, state, onAction, redo) {
  var histOptions = historyKey.get(state).options.config
  var pop = (redo ? history.undone : history.done).popEvent(state, histOptions.preserveItems)
  if (!pop) { return }

  var selectionBefore = state.selection
  var selection = Selection.fromJSON(pop.transform.doc, pop.selection)
  var added = (redo ? history.done : history.undone).addTransform(pop.transform, selectionBefore.toJSON(), histOptions)

  var newHist = new HistoryState(redo ? added : pop.remaining, redo ? pop.remaining : added, null, 0)
  onAction(pop.transform.action({selection: selection, historyState: newHist, scrollIntoView: true, sealed: true}))
}

var historyKey = new PluginKey("history")

// :: (?Object) → Plugin
// Returns a plugin that enables the undo history for an editor.
//
//   config::-
//   Supports the following configuration options:
//
//     depth:: ?number
//     The amount of history events that are collected before the
//     oldest events are discarded. Defaults to 100.
//
//     newGroupDelay:: number
//     The delay between changes after which a new group should be
//     started. Defaults to 500 (milliseconds). Note that when changes
//     aren't adjacent, a new group is always started.
//
//     preserveItems:: ?bool
//     Whether to preserve the steps exactly as they came in. **Must**
//     be true when using the history together with the collaborative
//     editing plugin, to allow syncing the history when concurrent
//     changes come in. Defaults to false.
function history(config) {
  config = {depth: config && config.depth || 100,
            preserveItems: !!(config && config.preserveItems),
            newGroupDelay: config && config.newGroupDelay || 500}
  return new Plugin({
    key: historyKey,

    state: {
      init: function init() {
        return new HistoryState(Branch.empty, Branch.empty, null, 0)
      },
      applyAction: function applyAction(action, hist, state) {
        if (action.type == "transform")
          { return recordTransform(hist, state.selection, action, config) }
        if (action.type == "historyClose")
          { return new HistoryState(hist.done, hist.undone, null, 0) }
        return hist
      }
    },

    config: config
  })
}
exports.history = history

// :: (state: EditorState, onAction: ?(action: Action)) → bool
// A command function that undoes the last change, if any.
function undo(state, onAction) {
  var hist = historyKey.getState(state)
  if (!hist || hist.done.eventCount == 0) { return false }
  if (onAction) { histAction(hist, state, onAction, false) }
  return true
}
exports.undo = undo

// :: (state: EditorState, onAction: ?(action: Action)) → bool
// A command function that redoes the last undone change, if any.
function redo(state, onAction) {
  var hist = historyKey.getState(state)
  if (!hist || hist.undone.eventCount == 0) { return false }
  if (onAction) { histAction(hist, state, onAction, true) }
  return true
}
exports.redo = redo

// :: (EditorState) → number
// The amount of undoable events available in a given state.
function undoDepth(state) {
  var hist = historyKey.getState(state)
  return hist ? hist.done.eventCount : 0
}
exports.undoDepth = undoDepth

// :: (EditorState) → number
// The amount of redoable events available in a given editor state.
function redoDepth(state) {
  var hist = historyKey.getState(state)
  return hist ? hist.undone.eventCount : 0
}
exports.redoDepth = redoDepth
